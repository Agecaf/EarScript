# EarScript Specification.

Todo: Table of contents.


# Introduction

This is the language specification for the EarScript programming language.
This specification is intended for anyone interested in
implementing EarScript machines and compilers. 

EarScript is a  domain specific language which only supports integers,
and excels at procedural generation.

It is easy to parse, and virtual machines that run EarScript 
can be very easy to customize, making EarScript potentially
a good option for a scripting language that is compiled at runtime.


## Overview

EarScript's machines contain **tables**, each is a 2 dimensional array of integers.
Each of these integers is in a **cell**.
Each table has a **pen**, which points at one cell within the table.
The machine also keeps track of the **current table**, which is the table currently being used.
The **current cell** is the cell under the pen of the current table.

EarScript's code primarily has instructions to manipulate these tables,
through movement of the pen, and manipulation of the numbers the pen points to.

Other than table manipulation, EarScript also has many instructions to manipulate
the control flow of its code. 
These broadly use `()` for `if/else`-like conditional control flow,
`[]` for `for/while`-like loop control flow,
and `{}` for `switch`-like branching control flow.


## Use Cases

EarScript should be easy to embed into applications, where virtual machines can be made to sandbox the execution of EarScript code.

EarScript was first implemented to be used in the rhythm game 
[EternAlgoRhythm](https://www.agecaf.eu/eternalgorhythm.html)
to procedurally generate music and charts.
Each note's pitch, velocity, duration, time of occurrence
and note type, were represented by integers, and were generated by EarScript code.

EarScript should be useful to generate anything that, like musical notes,
can be represented by integers.


## Preliminary examples

As an equivalent to "Hello World" program, we simply output the number from which all meaning can be derived.
```
# This is a comment
=42. # Output: 42
```

In this program, we output the numbers from 1 to 10.
```
[10 +.]
# Output: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.
```

In this program, we infinitely output consecutive integers,
which randomly go up or down.
```
[i{r+|-}.]
# Example output: 1, 0, 1, 2, 3, 2, 3, 2, 1, 0, 1, 0, ...
```



# EarScript Machines

EarScript code determines the behavior of an EarScript **machine**.

Each machine has things in common with all other machines,
however each machine is allowed, encouraged even,
to possess behaviour different from that of other machines.

This in practice means that EarScript code should target a
specific machine, and if this code is run by a different machine,
the behavior intended by the developer might not match the one of the machine.

A machine's internal data includes the **tables** it manages,
as well as the **code** it executes.


## Tables

A **table** is a finite 2 dimensional array of **cells**, 
each containing an integer, which is 0 by default.
The table's default size is 1x1, and a table's size can never
have fewer than one row or one column.

The integers contained in a table's cell are mutable.

> The integer specification used (operations, size, overflow behaviour, division by 0, NaN) 
> is up to the machine, but I recommend using whichever is simplest to set up.

Each table has a **pen**, which points at one of the cells
inside the table. The pen can be thought of as a pointer.
The pen can be moved around the table. 
If a pen is moved beyond the edges of the table, it wraps around.

For example
```
\ncol3       # Changes the number of rows to 3
=0 > =1 > =2 # Initializes the table to [0 1 2]
[i > .]      # Outputs: 0 1 2 0 1 2 0 1 2 0 1 2...
```

The machine can have as many tables as the user requests, in theory.
In practice, each machine can choose a maximum size of tables,
and a maximum number of tables.

At every point in the execution of the machine's code, 
the machine keeps track of the **current table**.
The **current cell** is the cell pointed at by the
current table's pen.

By default a machine's initial state includes
a single table of size 1x1.


## The code

A machine's internal state includes the code it is running,
as this code has state of its own and may change itself.

The code is usually an intermediate representation from
EarScript, such as EarByte bytecode,
but each implementation of EarScript can choose what this
intermediate representation is.
EarScript could be transpiled to static code in another
language, in which case the "code's state" would
simply be part of the machine's internal state.

Implementations of EarScript can, but don't need to,
include both a compiler from EarScript to an intermediate
representation, and an implementation of machine
that can be extended by users.


## Running a machine

Each machine might have different running behaviour.

Some may choose to run its code from start to finish;
others may loop back to the beginning once it reaches
the end of its code, and runs until a specific amount of output is
obtained.

Provisions to avoid infinite loops should be made by
the machine. For example, by running 1000 steps of 
the code at a time, and if no output has been obtained
stop the execution, otherwise continue running
until sufficient output is obtained.


## Customizing a machine

A machine must implement a "default input" and "default output"
functions, that are called from EarScript by `,` and `.`
respectively. They could just do nothing.

These functions should take as input a number and the machine itself,
and do whatever they wish. The value of the number is, for example, when calling 
`.5` from EarScript, `5`; and the default value of the number when calling `.`
is `1`.

For example, one could set up `.` to print the value of the current cell, 
`.2` to print the current table, 
and `.3` to print the whole machine.

Or the machine instead could have `.` generate an object from the
internal data of the table, with `.2` etc used for variations.

Similarly the user may request input by using `,`,
and the machine may implement this input as it sees fit,
perhaps it reads from standard input,
perhaps it gives a random number,
perhaps it gives a number from a stack,
perhaps it formats the table in a specific way.

The machine may define custom inputs and outputs, like 
`.print`, or `,rand`.

The machine may define custom operators using
the special delimiter, like `\sortTable`.

The machine may define custom opening delimiters
though this may be more complicated to do.
For instance `(isTableAllZero  )`.



# Grammar Specification

The following specification uses EBNF notation with ReGex in `/.../`.

```ebnf
program     = { line, "\n" }, [ line ];
line        = [ expression ], [ comment ];
comment     = "#", { /[^\n]*/ };
expression  = { whitespace | switch | loop | conditional | other_token };
whitespace  = "\t" | " ";
switch      = /{\w*/, { expression, "|" }, expression, "}";
loop        = /\[\w*/, expression, "]";
conditional = /(\w*/, { expression, "|" }, expression, ")";
other_token = /[+\-*\/!&?=><:^`;$@'"~\\.,\\]\w*/;
```

A **token** uses the following regex expressions;

```regex
/[+\-*\/!&?=><:^`;$@'"~\\.,|()\[\]{}]\w*/
```

**Tokens** include `other_token` as well as the **delimiters** of `switch`, `loop`, and `conditional`.
Examples of these are `)`, `}`, `]` for the **closing delimiters**, 
`|` for the **separator delimiter**, and `[`, `[i`, `[4`, `(eq0`, `{`, `{r`, etc.
for the **opening delimiters**.

Each token begins with one of the following **opertator characters**;
```
+ - * / ! & ? = > < : ^ ` ; $ @ ' " ~ \ . , | ( ) [ ] { }
```

Each token is made of an operator character followed by alphanumeric characters
```
a-Z A-Z 0-9 _
```

A token ends when whitespace/newline is found, 
when a new token begins with an operator character, 
or when a comment starts with `#`.

For example, given `[i{r+3|-value}.]`, 
the tokens are `[i`, `{r`, `+3`, `|`, `-value`, `}`, `.` and `]`.

A program, once comments are removed, should
be made of exclusively of a sequence of tokens,
optionally separated by whitespace and newlines.


## Lexical errors

If there's a program where there's a group of alphanumerical characters
not preceded by an operator character, such as
```
# The following is an invalid program
print("Hello World!")
```
then this constitutes lexical errors 
(in this case in the `print` and `World` words, as everything else is a valid token).

An implementation of EarScript can choose whether to report these errors.

An implementation of EarScript can choose whether characters which are not an operator 
character or alphanumeric characters, and which are outside of a comment, are
- Reported as errors.
- Treated as alphanumeric characters.
- Ignored.


## Syntax errors

If `{`, `[` and `(` are not matched with the appropriate `}`, `]` and `)`,
this constitutes a syntax error.

An implementation of EarScript can choose whether to report this as a syntax
error, or whether to recover by doing all of the following;
- Allow `)`, `]` and `}` to be exchanged with each other.
- Add as many `)`/`]`/`}` as needed at the end of the program.
- Ignore any extraeneous `|`, `)`, `]` or `}`.




# Anatomy of a Token

Tokens in EarScript are slightly different compared to tokens in other programming languages.
Each token has a **head** and a **tail**, the head usually has information on what
the token does, while the tail is an integer or a reference to an integer.

For example, in `+3`, the head is `+` and the tail is `3`.

If a token has no tail, like `+` or `>`, then the tail's value is implicitly `1`.

## Operator Character

The first character of a token is its **operator character**. 
The operator character is always part of the head of the token,
but in some cases the head of the token may include more
than just the operator character.

The types of operator characters are

- **Integer operators**
```
= + - * / ! & ?
```
- **Movement operators**
```
$ > < ^ ` : ;
```
- **Input/Output operators**
```
. ,
```
- **Flow operators**
```
@ ' " ~
```
- **Opening delimiters**
```
{ ( [
```
- **Closing delimiters**
```
} ) ]
```
- **Separator delimiter**
```
|
```
- **Special operator**
```
\
```

## Splitting the head from the tail

If the operator character of the token is the separator delimiter `|`, 
or a closing delimiter `)`, `}`, `]`,
then the token shouldn't have a tail.
An implementation of EarScript can choose whether
to report this as a lexical error, or to ignore the tail.

> There is no special reason why these shouldn't have a tail,
> I simply have not found an use for them yet.
> If you wish to implement behavior where it makes sense for
> these delimiters to have a tail, go for it.

If the operator character of the token is
an opening delimiter `(`, `[`, `{`,
is the special delimiter `\`,
or is an input/output operatot `.`, `,`
then the head contains every `[a-zA-Z]` character 
until the first `[_0-9]` character;
and the tail contains all characters from the
first `[_0-9]` character to the end of the token.

If the operator character is an integer, movement,
or flow operator then the head is the operator character,
and everything else is the tail.

### Examples

The following examples follow the pattern `token head tail`.
```
+        +
+3       +      3
-l2      -      l2
*_1      *      _1
$fwd     $      fwd
@start   @      start
\gcd2    \gcd   2
\nrow_x  \nrow  _x
{r3      {r     3
[i       [i
(eq_x    (eq    _x
}        }
```

## The Head

The head of a token determines its functionality, for example
- `$` Creates or moves to a table.
- `{r` randomly chooses a branch to execute.
- `[` Loops n times, based on the tail.
- `.` Outputs something.

The standard heads forms a basis of the functionality for EarScript.

Anyone implementing EarScript may choose to include additional
heads by creating new heads whose operator character is
the special operator `\`, opening delimiters `(`, `[`, `{`,
or the input/output operators `,`, `.`.

This allows different machines to have different behaviors,
and for users to customize existing machines.


## The Tail

There exists many types of tails. All except label references can be evaluated
to an integer.

- **Table references**: These refer to a table,
and can be evaluated to the number under the table's pen.
A table reference optionally starts with `_`,
and otherwise the first character must be in `[a-zA-Z]`.
The exceptions are that the following are that not allowed to be table references;
`r`, `l`, `u`, `d`, `_r`, `_l`, `_u`, `_d`.
A table reference evaluates to the cell under the referred table's pen.
For example, `+X` adds the value of the cell under table `X`'s pen to the current cell.

- **Label references**: These are exclusively used by the flow
operators `@`, `'`, `"`. They refer to a place in the code.
For example `@start` labels a place in the code as the `@start` label,
and `'label` jumps the code execution to the `@start` label.

- **Positive integers**: These are of the form `/[0-9]+/`.
They evaluate to the integer in question. For example `+3` adds `3` to the current cell.

- **Negative integers**: These are of the form `/_[0-9]+/`.
They evaluate to a negative number. For example `+_3` adds `-3` to the current cell,
while this can be done with `-3`, some operators do not have negative variants like
`=` or `*`.

- **Relative reference**: These are of the form `/[0-9]*[udlr]/` or `_?[udlr]`.
They refer to cells in the current table located to the left, right, up or down.
For example `+l` adds the value of the cell to the left of the current cell, to the current cell.
While `+3l` adds the value of the cell three spaces to the left of the current cell, to the current cell.

- **Self reference**: This is of the form `_` and evaluates to the value of the
current cell. For example `+_` adds the value of the current cell to itself.

- **Empty tail**: This always evaluates to `1`. For example `+` and `+1` are equivalent,
and increase the value of the current cell by 1.







# Standard Heads

In this section we specify the behavior of each of the standard token heads.
Keep in mind that each machine may implement additional heads,
examples are provided.


## Assignment

The head `=` sets the value of the current cell to the value of the token's tail.

For example the token `=` sets the current cell's value to `1`,
while the `=42` token sets it to `42`.


## Input / Output

The head `.` calls the machine's standard output, which may
use the tail or ignore its value.
Similarly, the head `,` call's the machine's standard input.

Each machine may optionally implement additional
output heads such as `.print`,
or input heads such as `,dayOfMonth`.

Users can expect output methods to not make any
changes to the machine's tables, and use the 
current cell, current table, or state of all tables
to ouptut something.

Users can expect input methods to not depend on the 
state of the tables, and to make changes
to the current cell, current table, or state of all tables.

For methods that consider the state of the table
and make changes to the table, machines should
instead consider implementing heads
which use the special operator `\`,
such as `\sortRow`.

### Example

Suppose that the machine's implementation has
`.` print the current cell to standard output,
`.2` print the current table to standard ouput.

```
\ncol3          # Sets the number of columns to 3
=1 > =2 > =3    # sets the table to  [1 2 3]
.               # Output: 3
.2              # Output: [1 2 3]
```

## Operations

These heads modify the current cell's value `a` by
combining it with the value of the token's tail `b`.

- `+` Addition of `a` and `b`.
- `-` Subtraction of `a` minus `b`.
- `*` Multiplication of `a` and `b`.
- `/` Integer division of `a` divided by `b`, the highest integer which when multiplied by `b` is less than or equal to `a`.
- `%` Integer positive modulo of `a` modulo `b`, the integer between `0` inclusive and `b` exclusive which has the same remainder as `a` when divided by `b`.
- `!` Bitwise not of `a` and `b`.
- `&` Bitwise and of `a` and `b`.
- `?` Bitwise or of `a` and `b`.
- `\pow` Power of `a` to the power `|b|`.
- `\min` Minimum of `a` and `b`.
- `\max` Maximum of `a` and `b`.

The following are optional additions.
- `\log` Floor of logarithm of `|a|` with base the number `|b|`, or `-1` if `a` is `0`.
- `\xor` Bitwise xor of `a` and `b`.
- `\gcd` Positive greatest common divisor of `a` and `b`.
- `\lcm` Positive lowest common multiple of `a` and `b`.
- `\abs` Absolute value of `a`.
- `\sgn` `1` if `a` is positive, `-1` if `a` is negative, `0` if `a` is zero.

An example program would be
```
=0 .       # Output: 0
+  .       # Output: 1
-2 .       # Output: -1
*_1.       # Output: 1
=13 /5 .   # Output: 2
=13 %5 .   # Output: 3
=_13 /5 .  # Output: -3
=_13 %5 .  # Output: 2
```


# EarScript Specification.

Todo: Table of contents.


# Introduction

This is the language specification for the EarScript programming language.
This specification is intended for anyone interested in
implementing EarScript machines and compilers. 

EarScript is a  domain specific language which only supports integers,
and excels at procedural generation.

It is easy to parse, and virtual machines that run EarScript 
can be very easy to customize, making EarScript potentially
a good option for a scripting language that is compiled at runtime.


## Overview

EarScript's machines contain **tables**, each is a 2 dimensional array of integers.
Each of these integers is in a **cell**.
Each table has a **pen**, which points at one cell within the table.
The machine also keeps track of the **current table**, which is the table currently being used.
The **current cell** is the cell under the pen of the current table.

EarScript's code primarily has instructions to manipulate these tables,
through movement of the pen, and manipulation of the numbers the pen points to.

Other than table manipulation, EarScript also has many instructions to manipulate
the control flow of its code. 
These broadly use `()` for `if/else`-like conditional control flow,
`[]` for `for/while`-like loop control flow,
and `{}` for `switch`-like branching control flow.


## Use Cases

EarScript should be easy to embed into applications, where virtual machines can be made to sandbox the execution of EarScript code.

EarScript was first implemented to be used in the rhythm game 
[EternAlgoRhythm](https://www.agecaf.eu/eternalgorhythm.html)
to procedurally generate music and charts.
Each note's pitch, velocity, duration, time of occurrence
and note type, were represented by integers, and were generated by EarScript code.

EarScript should be useful to generate anything that, like musical notes,
can be represented by integers.


## Preliminary examples

As an equivalent to "Hello World" program, we simply output the number from which all meaning can be derived.
```
# This is a comment
=42. # Output: 42
```

In this program, we output the numbers from 1 to 10.
```
[10 +.]
# Output: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.
```

In this program, we infinitely output consecutive integers,
which randomly go up or down.
```
[i{r+|-}.]
# Example output: 1, 0, 1, 2, 3, 2, 3, 2, 1, 0, 1, 0, ...
```



# EarScript Machines

EarScript code determines the behavior of an EarScript **machine**.

Each machine has things in common with all other machines,
however each machine is allowed, encouraged even,
to possess behaviour different from that of other machines.

This in practice means that EarScript code should target a
specific machine, and if this code is run by a different machine,
the behavior intended by the developer might not match the one of the machine.

A machine's internal data includes the **tables** it manages,
as well as the **code** it executes.


## Tables

A **table** is a finite 2 dimensional array of **cells**, 
each containing an integer, which is 0 by default.
The table's default size is 1x1, and a table's size can never
have fewer than one row or one column.

The integers contained in a table's cell are mutable.

> The integer specification used (operations, size, overflow behaviour, division by 0, NaN) 
> is up to the machine, but I recommend using whichever is simplest to set up.

Each table has a **pen**, which points at one of the cells
inside the table. The pen can be thought of as a pointer.
The pen can be moved around the table. 
If a pen is moved beyond the edges of the table, it wraps around.

For example
```
\ncol3       # Changes the number of rows to 3
=0 > =1 > =2 # Initializes the table to [0 1 2]
[i > .]      # Outputs: 0 1 2 0 1 2 0 1 2 0 1 2...
```

The machine can have as many tables as the user requests, in theory.
In practice, each machine can choose a maximum size of tables,
and a maximum number of tables.

At every point in the execution of the machine's code, 
the machine keeps track of the **current table**.
The **current cell** is the cell pointed at by the
current table's pen.

By default a machine's initial state includes
a single table of size 1x1.


## The code

A machine's internal state includes the code it is running,
as this code has state of its own and may change itself.

The code is usually an intermediate representation from
EarScript, such as EarByte bytecode,
but each implementation of EarScript can choose what this
intermediate representation is.
EarScript could be transpiled to static code in another
language, in which case the "code's state" would
simply be part of the machine's internal state.

Implementations of EarScript can, but don't need to,
include both a compiler from EarScript to an intermediate
representation, and an implementation of machine
that can be extended by users.


## Running a machine

Each machine might have different running behaviour.

Some may choose to run its code from start to finish;
others may loop back to the beginning once it reaches
the end of its code, and runs until a specific amount of output is
obtained.

Provisions to avoid infinite loops should be made by
the machine. For example, by running 1000 steps of 
the code at a time, and if no output has been obtained
stop the execution, otherwise continue running
until sufficient output is obtained.


## Customizing a machine

A machine must implement a "default input" and "default output"
functions, that are called from EarScript by `,` and `.`
respectively. They could just do nothing.

These functions should take as input a number and the machine itself,
and do whatever they wish. The value of the number is, for example, when calling 
`.5` from EarScript, `5`; and the default value of the number when calling `.`
is `1`.

For example, one could set up `.` to print the value of the current cell, 
`.2` to print the current table, 
and `.3` to print the whole machine.

Or the machine instead could have `.` generate an object from the
internal data of the table, with `.2` etc used for variations.

Similarly the user may request input by using `,`,
and the machine may implement this input as it sees fit,
perhaps it reads from standard input,
perhaps it gives a random number,
perhaps it gives a number from a stack,
perhaps it formats the table in a specific way.

The machine may define custom inputs and outputs, like 
`.print`, or `,rand`.

The machine may define custom operators using
the special delimiter, like `\sortTable`.

The machine may define custom opening delimiters
though this may be more complicated to do.
For instance `(isTableAllZero  )`.



# Grammar Specification

The following specification uses EBNF notation with ReGex in `/.../`.

```ebnf
program     = { line, "\n" }, [ line ];
line        = [ expression ], [ comment ];
comment     = "#", { /[^\n]*/ };
expression  = { whitespace | switch | loop | conditional | other_token };
whitespace  = "\t" | " ";
switch      = /{\w*/, { expression, "|" }, expression, "}";
loop        = /\[\w*/, expression, "]";
conditional = /(\w*/, { expression, "|" }, expression, ")";
other_token = /[+\-*\/%!&?=><:^`;$@'"~\\.,\\]\w*/;
```

A **token** uses the following regex expressions;

```regex
/[+\-*%\/!&?=><:^`;$@'"~\\.,|()\[\]{}]\w*/
```

**Tokens** include `other_token` as well as the **delimiters** of `switch`, `loop`, and `conditional`.
Examples of these are `)`, `}`, `]` for the **closing delimiters**, 
`|` for the **separator delimiter**, and `[`, `[i`, `[4`, `(eq0`, `{`, `{r`, etc.
for the **opening delimiters**.

Each token begins with one of the following **opertator characters**;
```
+ - * / % ! & ? = > < : ^ ` ; $ @ ' " ~ \ . , | ( ) [ ] { }
```

Each token is made of an operator character followed by alphanumeric characters
```
a-Z A-Z 0-9 _
```

A token ends when whitespace/newline is found, 
when a new token begins with an operator character, 
or when a comment starts with `#`.

For example, given `[i{r+3|-value}.]`, 
the tokens are `[i`, `{r`, `+3`, `|`, `-value`, `}`, `.` and `]`.

A program, once comments are removed, should
be made of exclusively of a sequence of tokens,
optionally separated by whitespace and newlines.


## Lexical errors

If there's a program where there's a group of alphanumerical characters
not preceded by an operator character, such as
```
# The following is an invalid program
print("Hello World!")
```
then this constitutes lexical errors 
(in this case in the `print` and `World` words, as everything else is a valid token).

An implementation of EarScript can choose whether to report these errors.

An implementation of EarScript can choose whether characters which are not an operator 
character or alphanumeric characters, and which are outside of a comment, are
- Reported as errors.
- Treated as alphanumeric characters.
- Ignored.


## Syntax errors

If `{`, `[` and `(` are not matched with the appropriate `}`, `]` and `)`,
this constitutes a syntax error.

An implementation of EarScript can choose whether to report this as a syntax
error, or whether to recover by doing all of the following;
- Allow `)`, `]` and `}` to be exchanged with each other.
- Add as many `)`/`]`/`}` as needed at the end of the program.
- Ignore any extraeneous `|`, `)`, `]` or `}`.




# Anatomy of a Token

Tokens in EarScript are slightly different compared to tokens in other programming languages.
Each token has a **head** and a **tail**, the head usually has information on what
the token does, while the tail is an integer or a reference to an integer.

For example, in `+3`, the head is `+` and the tail is `3`.

If a token has no tail, like `+` or `>`, then the tail's value is implicitly `1`.

## Operator Character

The first character of a token is its **operator character**. 
The operator character is always part of the head of the token,
but in some cases the head of the token may include more
than just the operator character.

The types of operator characters are

- **Integer operators**
```
= + - * / ! & ? %
```
- **Movement operators**
```
$ > < ^ ` : ;
```
- **Input/Output operators**
```
. ,
```
- **Flow operators**
```
@ ' " ~
```
- **Opening delimiters**
```
{ ( [
```
- **Closing delimiters**
```
} ) ]
```
- **Separator delimiter**
```
|
```
- **Special operator**
```
\
```

## Splitting the head from the tail

If the operator character of the token is the separator delimiter `|`, 
or a closing delimiter `)`, `}`, `]`,
then the token shouldn't have a tail.
An implementation of EarScript can choose whether
to report this as a lexical error, or to ignore the tail.

> There is no special reason why these shouldn't have a tail,
> I simply have not found an use for them yet.
> If you wish to implement behavior where it makes sense for
> these delimiters to have a tail, go for it.

If the operator character of the token is
an opening delimiter `(`, `[`, `{`,
is the special delimiter `\`,
or is an input/output operatot `.`, `,`
then the head contains every `[a-zA-Z]` character 
until the first `[_0-9]` character;
and the tail contains all characters from the
first `[_0-9]` character to the end of the token.

If the operator character is an integer, movement,
or flow operator then the head is the operator character,
and everything else is the tail.

### Examples

The following examples follow the pattern `token head tail`.
```
+        +
+3       +      3
-l2      -      l2
*_1      *      _1
$fwd     $      fwd
@start   @      start
\gcd2    \gcd   2
\nrow_x  \nrow  _x
{r3      {r     3
[i       [i
(eq_x    (eq    _x
}        }
```

## The Head

The head of a token determines its functionality, for example
- `$` Creates or moves to a table.
- `{r` randomly chooses a branch to execute.
- `[` Loops n times, based on the tail.
- `.` Outputs something.

The standard heads forms a basis of the functionality for EarScript.

Anyone implementing EarScript may choose to include additional
heads by creating new heads whose operator character is
the special operator `\`, opening delimiters `(`, `[`, `{`,
or the input/output operators `,`, `.`.

This allows different machines to have different behaviors,
and for users to customize existing machines.


## The Tail

There exists many types of tails. All except label references can be evaluated
to an integer.

- **Table references**: These refer to a table,
and can be evaluated to the number under the table's pen.
A table reference optionally starts with `_`,
and otherwise the first character must be in `[a-zA-Z]`.
The exceptions are that the following are that not allowed to be table references;
`r`, `l`, `u`, `d`, `_r`, `_l`, `_u`, `_d`.
A table reference evaluates to the cell under the referred table's pen.
For example, `+X` adds the value of the cell under table `X`'s pen to the current cell.

- **Label references**: These are exclusively used by the flow
operators `@`, `'`, `"`. They refer to a place in the code.
For example `@start` labels a place in the code as the `@start` label,
and `'label` jumps the code execution to the `@start` label.

- **Positive integers**: These are of the form `/[0-9]+/`.
They evaluate to the integer in question. For example `+3` adds `3` to the current cell.

- **Negative integers**: These are of the form `/_[0-9]+/`.
They evaluate to a negative number. For example `+_3` adds `-3` to the current cell,
while this can be done with `-3`, some operators do not have negative variants like
`=` or `*`.

- **Relative reference**: These are of the form `/[0-9]*[udlr]/` or `_?[udlr]`.
They refer to cells in the current table located to the left, right, up or down.
For example `+l` adds the value of the cell to the left of the current cell, to the current cell.
While `+3l` adds the value of the cell three spaces to the left of the current cell, to the current cell.

- **Self reference**: This is of the form `_` and evaluates to the value of the
current cell. For example `+_` adds the value of the current cell to itself.

- **Empty tail**: This always evaluates to `1`. For example `+` and `+1` are equivalent,
and increase the value of the current cell by 1.







# Standard Heads

In this section we specify the behavior of each of the standard token heads
which are not delimiters.
Keep in mind that each machine may implement additional heads,
examples are provided.


## Assignment

The head `=` sets the value of the current cell to the value of the token's tail.

For example the token `=` sets the current cell's value to `1`,
while the `=42` token sets it to `42`.


## Input / Output

The head `.` calls the machine's standard output, which may
use the tail or ignore its value.
Similarly, the head `,` call's the machine's standard input.

Each machine may optionally implement additional
output heads such as `.print`,
or input heads such as `,dayOfMonth`.

Users can expect output methods to not make any
changes to the machine's tables, and use the 
current cell, current table, or state of all tables
to ouptut something.

Users can expect input methods to not depend on the 
state of the tables, and to make changes
to the current cell, current table, or state of all tables.

For methods that consider the state of the table
and make changes to the table, machines should
instead consider implementing heads
which use the special operator `\`,
such as `\sortRow`.

### Example

Suppose that the machine's implementation has
`.` print the current cell to standard output,
`.2` print the current table to standard ouput.

```
\ncol3          # Sets the number of columns to 3
=1 > =2 > =3    # sets the table to  [1 2 3]
.               # Output: 3
.2              # Output: [1 2 3]
```

## Operations

These heads modify the current cell's value `a` by
combining it with the value of the token's tail `b`.

- `+` Addition of `a` and `b`.
- `-` Subtraction of `a` minus `b`.
- `*` Multiplication of `a` and `b`.
- `/` Integer division of `a` divided by `b`, the highest integer which when multiplied by `b` is less than or equal to `a`.
- `%` Integer positive modulo of `a` modulo `b`, the integer between `0` inclusive and `b` exclusive which has the same remainder as `a` when divided by `b`.
- `!` Bitwise not of `a` and `b`.
- `&` Bitwise and of `a` and `b`.
- `?` Bitwise or of `a` and `b`.
- `\pow` Power of `a` to the power `|b|`.
- `\min` Minimum of `a` and `b`.
- `\max` Maximum of `a` and `b`.

The following are optional additions.
- `\log` Floor of logarithm of `|a|` with base the number `|b|`, or `-1` if `a` is `0`.
- `\xor` Bitwise xor of `a` and `b`.
- `\gcd` Positive greatest common divisor of `a` and `b`.
- `\lcm` Positive lowest common multiple of `a` and `b`.
- `\abs` Absolute value of `a`.
- `\sgn` `1` if `a` is positive, `-1` if `a` is negative, `0` if `a` is zero.

An example program would be
```
=0 .       # Output: 0
+  .       # Output: 1
-2 .       # Output: -1
*_1.       # Output: 1
=13 /5 .   # Output: 2
=13 %5 .   # Output: 3
=_13 /5 .  # Output: -3
=_13 %5 .  # Output: 2
```



## Table movement and manipulation

The machine has a collection of tables, one of which is the current table.
Each table has its own pen, which points at one of the cells within the table.

The table's columns and rows are numbered starting at zero
and ending at one less than the column size.
So the column at index 0 is the first column.


### Moving between tables, creating tables

The `$` head only allows table references to be its tail.
If the table reference is not found within the current collections
of table references, then a new table is created for this table reference.
Then, `$` moves to the referred table, making it the current table.

There is one exception to this rule; `$` on its own returns to the
default, initial table. 
Furthermore, the first time `$` has a table reference,
this links the table reference to the default table, 
instead of creating a new table.

```
$main    # Names the default table main
$other   # Creates table other, moves to other.
$        # Returns to the main table.
$other   # Moves to the table other.
$X=3$    # Creates a new table X, moves to it, sets its value to 3, returns to main.
=X       # Sets the current cell's value (in main) to the value in X.
```

### Resizing tables

A table, by default, has size 1x1. A table can be resized, 
but its number of rows and its number of columns must always be at least be 1.

The head `\nrow` and `\ncol` change the
number of rows and columns, respectively, in the current table.

If new cells are added to the table, they must be initialized to 0.

A resizing of the table should preserve the pen's position,
if the pen would point to a position outside the table, then it
wraps around so that the previous pen position and the new pen position
are congruent modulo the new size of the table.

```
\ncol20   # Sets the number of columns to 20
:13       # Moves pen to column index 13
\ncol5    # Sets the number of columns to 5, the new pen position should be at index 3.
```

### Pen movement

- `>` Moves the pen right, increasing the column index.
- `<` Moves the pen left, decreasing the column index.
- `^` Moves the pen up, increasing the row index.
- `` ` `` Moves the pen down, decreasing the row index.
- `:` Moves to a specific column.
- `;` Moves to a specific row.

By convention, we often write a table where the first
row is the first line, the second row is the second line,
etc. which makes it seem like going up is going down.

All pen movement has wrap-around behavior;
if the pen ends up outside the bounds of the table,
then it moves to the position which is congruent
modulo the dimensions of the table.

For example, `:_1` moves the pen to the last column;
and if the pen is in the last column, `>` moves it back to the first column.



## Flow operators

Flow operators work like labels, goto statements and function calls.
They are used to jump from one part of the machine's code to another.

The machine keeps a call stack of locations in the code to return to,
similar call stacks in other programming languages.

The `@`, `'` and `"` heads all take a label reference as its tail.
The `~` head 

- `@` Label: set the position of a label within the code,
and otherwise does nothing.

- `'` Goto: jumps the code directly to the position of the label reference,
similar to a goto statement.

- `"` Goto-Return: pushed the current code location to the call stack,
then jumps to the position of the label reference.

- `~` Return: Pops the value in the call stack and returns to the location in the code,
if the call stack is empty jumps to the end of the program.

Users should not redefine the position of a label.
An implementation of EarScript can choose whether to report this as a syntax error,
or to not report an error and have the goto and goto-return
statements target the first occurrence of the label.

If a user tries to jump to a non-existing label, 
An implementation of EarScript can choose whether to report this as a syntax error,
or to do nothing and continue with the execution of the code.

```
'start             # Jumps to the start label, skipping function declarations.
@function + . ~    # "Defines a function", increases the current cell and prints it.
@start \ncol2      # Start of the program, increases the size of the table.
@loop              # Sets loop label for an infinite loop.
"function >        # Calls function, then moves right 
'loop              # Jumps to the start of the loop, for an infinite loop.
                   # Output: 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, ...
```

In theory, there could be as many labels as the user wishes,
but in practice there may be a maximum number of labels,
an implementation of EarScript can choose this maximum.




# Delimiter Heads

Delimiter heads are the most complex part of EarScript. 
They also provide some of its most powerful features.

Loosely speaking,

- `[` heads are loops, with a single banch,
- `(` heads are conditionals, with either one or two branches,
- `{` heads are switches, with two or more branches.

Where a **branch** is what is between
two associated delimiters, including the separator delimiter `|`
for when there's two or more branches.

```
{r=1|=2|=3|=4}   # This has 4 branches.
(eq0 +3 *_2 .)   # This has a single branch.
[i {=0|=3} .]    # The [i loop has a single branch, the interior { switch has two branches.
```


## Loop heads

Loops are heads whose operator character is `[`.
They have a single branch and will loop back to
the beginning of the branch under certain conditions.

- `[` tail of value 1, will loop back to the beginning if once `]`
is reached, the current cell's value is nonzero.
This matches the looping behavior of `[]` in brainfuck,
but not the conditional behavior. `[]` in brainfuck
is equivalent to `([])` in EarScript.

- `[` with a positive tail larger than `1` will loop
as many times as the value of the tail.

- `[i` is an infinite loop.

- `[r` will loop back to the beginning with probability
`b/(1+b)` where `b` is the value of the tail.

```
[4 +.]      # Output: 1, 2, 3, 4.
[-.]        # Output: 3, 2, 1, 0.
=0 [r4+] .  # Output: a number around 4.
=42 [i .]   # Output: 42, 42, 42, 42, 42, 42, ...
```

Note that loops can be "escaped" through flow operators.


## Conditional heads

Conditionals are heads whose operator character is `(`.

Conditionals usually test whether a condition is true.

If the conditional has a single branch,
then if the condition is true the branch is executed, 
and if the condition is false, the branch is skipped.
This is similar to `if` statements in other languages.

If the conditional has two branches,
then if the condition is true then the
first branch is executed and the second branch is skipped;
and if the condition is false then the
first branch is skipped and the second branch is executed.

Let `a` be the value of the current cell and `b` be the value of the tail.
- `(` True if `a` is nonzero.
- `(eq` True if `a` and `b` are equal.
- `(ne` True if `a` and `b` are not equal.
- `(lt` True if `a` is less than `b`.
- `(gt` True if `a` is greater than `b`.
- `(le` True if `a` is less than or equal to `b`.
- `(ge` True if `a` is greater than or equal to `b`.
- `(div` True if `a` is a multiple of `b`.

The following has conditions which change each time the code returns to this token.
- `(x` Expend; True the first `b` times it is executed, then False.
- `(c` Cycle/Alternate; True `b` times, then false once, then true `b` times again, then false once, etc.
- `(r` True with probability `1/(b+1)`, false with probability `b/(b+1)`.

```
[10 (x3 +) .]   # Output: 1, 2, 3, 3, 3, 3, 3, 3, 3, 3.
[10 (c3 +) .]   # Ouptut: 1, 2, 3, 3, 4, 5, 6, 6, 7, 8.
[10 (r3 +) .]   # Output Example: 1, 1, 1, 2, 2, 2, 2, 2, 2, 2.
                # Output Example: 0, 0, 0, 1, 1, 2, 2, 2, 2, 3.
```


## Switch heads

Switch heads select between two or more branches,
and execute this branch.

Let `n` be the value of the tail.
- `{` Sequencer. Cycles through each branch, repeating each `n` times before moving to the next.
```
[9 {=1|=2|=3} . ]   # Output: 1, 2, 3, 1, 2, 3, 1, 2, 3.
[8 {2 =0|=1} . ]    # Output: 0, 0, 1, 1, 0, 0, 1, 1.
```

- `{r` Randomizer. Randomly chooses a branch. If `n` is zero, only makes the random choice once, and repeats this choice onwards.
If `n` is larger than one, it repeats each random choice `n` times before re-randomizing.

```
[8 {r0=1|=2|=3} . ]  # Output Example: 3, 3, 3, 3, 3, 3, 3, 3.
[8 {r=1|=2|=3} . ]   # Output Example: 2, 1, 1, 3, 1, 3, 3, 2.
[8 {r2=1|=2|=3} . ]  # Output Example: 1, 1, 3, 3, 3, 3, 2, 2.
```

- `{s` Shuffler. Shuffles the branches, then cycles through them.
If `n` is zero, shuffles once. Otherwise shuffles every `n` times.
```
[12 {s0=1|=2|=3} . ]  # Output Example: 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 
[12 {s=1|=2|=3} . ]   # Output Example: 2, 1, 1, 3, 1, 3, 3, 2, 2, 2, 2, 1,
[12 {s6=1|=2|=3} . ]  # Output Example: 2, 3, 1, 2, 3, 1, 1, 2, 3, 1, 2, 3,
```

- `{m` should select the branch whose index matches the value of the current cell
modulo the number of branches.


## Custom delimiters

An implementation of EarScript may add additional delimiters,
such as custom conditionals like `(isTableAllZero`.




# Meta EarScript

EarScript files use the `.ear` extension.

In EarScript, comments use the `# ` notation.

A commend in the first line could be used as a shebang to choose the interpreter to use for
an EarScript file.

Comment lines could be used with the C pre-processor to
add macros to EarScript such as `#include`, `#define`, `#ifdef`, etc.

More generally, if an implementation of EarScript wants to add macros,
they can do so through special comments.

Comments can also be used for designating nodes/blocks in a
visual programming language version of EarScript, as does
the EarVis implementation.

Here's an example of a node used in EternAlgoRhythm's EarVis,
the first comment contains information on the position and
size of the node in the Graph-Node editor,
the first label is the name of the node,
the last comment mentions there's 1 possible output,
and the last goto statement links a block to another.

```
###N\\p1\\880\\220\\177\\105
@p1 $
$tempo=174$
###O\\1
'b2
```

This allows one to edit EarScript programs in
a visual way, while still saving these programs
as EarScript files.



